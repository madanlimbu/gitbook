---
description: Django quick notes
---

# Overview

### Model

Django comes with an Object relational mapper (ORM) to describe and manipulate with data.

Model are subclass of `django.db.models.Model`&#x20;

{% code title="" %}
```python
from django.db import models

class User(models.Model):
    name = models.CharField(max_length=70)
    
class Post(models.Model):
    title = models.CharField(max_length=70)
    body = models.TextField(blank=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.title
```
{% endcode %}

Django also provide database-access API.&#x20;

Model represents a Database-table and a record/row in table represents an instance of that model.

Each model represents by a class that subclasses `django.db.models.Model` and Each field is represented by an instance of  a `Field` class.

{% code title="app/post/db.py" %}
```python
from .models import User

user = User(name='madan') #instance of User
user.save() #insert to database
user.id #database primary-key id

#Django provides many api for database lookup
User.objects.all() #list of user
User.objects.get(id=1) #user with id 1
User.objects.get(name__statswith='madan')

#Django also handles the relational lookup
userPost = user.post #gets post related user
post.body #gets body field of post

#we can also deeply nest the query
Post.objects.filter(user__name__startswith='madan') #gets post by user whose name starts with "madan"

user.delete() #deletes the user
```
{% endcode %}

#### Serializers

Serializers helps convert complex data (querysets and model instances) to native Python datatypes which can be easily rendered into `JSON` , `XML` or other content types and vice versa ( deserialization ).

Django RESET framework provides `Serializer` and `ModelSerializer` class which helps accomplish this.&#x20;

{% code title="serializer.py" %}
```python
from django.db import models
from reset_framework import serializers
from reset_framework.parser import JSONParser

class Person(model.Model):
    def __init__(self, name):
        self.name = name
        
    def create(self, validated_data):
        return Person.objects.create(**validated_data)
        
    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        instance.save()
        return instance

class PersonSerializer(serializers.Serializer):
    name = serializers.TextField(blank=True)
    
    def create(self, validated_data):
        return Person(**validated_data)
    
    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        return instance

person = Person(name='madan')
personSer = PersonSerializer(person)
personSer.data
# {'name': 'madan'}

#Deserializing  
json = "{'name': 'madan'}"
data = JSONParser().parse(json) #parse into Python native datatypes

#restore native datatypes into a dictionary of validated data
serializer = PersonSerializer(data=data)
serializer.is_valid()
serializer.validated_data
# {'name': 'madan'}

person = serializer.save() #back to obj instance

#save() fnc will call update or create depending on data passed.
serializer = PersonSerializer(data=data) # create()
serializer = PersonSerializer(person, data=data) # update()
```
{% endcode %}

### Migrations

In Django, Migrations is a way of propagating changes from models to database schema.

The migration files for each app lives in a `migration` directory.

```python
#Most used cli to interact with migration

#stages/create new migration based on changes to model
python manage.py makemigrations

#or give a meaningful name to migraiton file
python manage.py makemigrations --name GOODNAME APPNAME

#apply changes from migrations
python manage.py migrate

#lists projects migraitons and their status
python manage.py showmigrations

#check/debug for any probleme before doing any migration to database
python manage.py check

#display SQL statemetns for the specific migration
python manage.py sqlmigrate PROJECT_NAME MIGRATION


```

Table names for model are automatically generated by combining the name of the `app`and the name of model.

Primary keys (IDs) are also added automatically

Django appends `_id` to foreign key field name

### Mapping URLs - URLconfs

In Django we can specify config to map URL to a callback.

The parameter tags `<>` are used to capture values from URL.

Django search from top to bottom for matching URL (`route` ), once the match is found, it stops and call the callback (`view` ).&#x20;

`path()` fnc takes in 4 parameters, two required `route` and `view`  and two optional `kwards` and `name` .

The callback function gets a request object (request metadata) and the values captured in the pattern. `callback(HtppRequest: request, name=madan)`&#x20;

The convention is put callback function inside `views.py`&#x20;

{% code title="app/post/urls.py" %}
```python
from django.urls import path, url, include

urlpatterns = [
    path('post/<int:pk>/', views.post),
    path('post/<string:title>/', views.post_title),
]

#we can also use regex and name the route for later use
urlpatterns = [
    url(r'^post/$', views.post_title, name=unique_route_name)
]

#we can use include() fnc to reference other URLconfs from other apps
urlpatterns = [
    path('test/', include('test_app.urls')),
]

```
{% endcode %}

{% code title="app/test_app.urls.py" %}
```python
from django.urls import path

urlpatterns = [
    path('', views.index),
    path('random/', views.random),
]

```
{% endcode %}

```python
#use case for unique url name
from django.core.urlresolvers 
from django.http import HttpResponseRedirect
    
#eg, we can use name of route to create a HttpResponseRedirect
def redirect_to_title(request):
    title = post_title
    return HttpResponseRedirect(reverse('unique_route_name', args=(title,)))  
    
```

view/callback are responsible for returning an `HttpResponse` object with request page contents or `Http404` on error.

{% code title="app/post/views.py" %}
```python
from django.shortcuts import render
from .models import Post

def post_title(request, title):
    #get posts with this title
    posts_list = Post.objects.filter(title__startswith=title)
    
    #put it into collection to be used in template
    context = {'title': title, 'posts_list': posts_list}
    
    #pass the request, context to template
    return render(request, 'post/title.html', context)
    
```
{% endcode %}

### Template

Django project can be configured with one or several template engines.&#x20;

Django defines a standard API for loading and rendering templates regardless of the backend.&#x20;

Django template language (DTL) is django's own template system.

Templates engines are configured with `TEMPLATES` setting, one for each engine.&#x20;

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplate'
        'DIRS': []
        'APP_DIRS': True,
        'OPTIONS': {},
    },
]

```

* `BACKEND` dotted path to template engine class implementing Django's template backend API.&#x20;
* `DIRS` list of directories for engines to look template in
* `APP_DIRS` tells Django to look for templates inside installed applications
* `OPTIONS` backend-specific settings

Templates are name-spaced by putting templates inside another sub-directory named for the application itself. Example: Instead of `app_name/templates/index.html` , use `app_name/templates/app_name/index.html`

This way even if there is two template with same name, Template loaders  can know how to find right template by just using `app_name/index.html` .

{% code title="app/views.py" %}
```python
from django.http import HttpResponse
from django.template import loader

def index(request):
    #loader to find and get the template obj
    tempalte = loader.get_template('app_name/index.html')
    context = {
        'body': 'hi, madan'
    }
    #return httpreponse with template rendering context/data
    return HttpResponse(template.render(context, request))
    
```
{% endcode %}

#### Template syntax

variables surrounded by double-curly braces `{{ post.titl }}` . Can use filter by piping variables `{{ post.date|date:"F j, Y" }}` . can write custom template filters and template tags. Also has template inheritance feature \`\{% extends "base.html" %\} ( loads base blocks and fills the blocks with following templates )&#x20;

{% code title="app/post/templates/post/title.html" %}
```python
{% raw %}
{% extends "base.html" %}

{% block title %}Posts with titile: {{ title }}{% endblock %}

{% block content %}
<h4>Posts title is {{ title }}</h4>
{% endblock %}
{% endraw %}
```
{% endcode %}

{% code title="app/templates/base.html" %}
```python
{% raw %}
{% load static %}
<html>
<head>
</head>
<body>
{% block content %}{% block %}
{% endraw %}
</body>
</html>
```
{% endcode %}

#### Command-line Util

`django-admin` and `manage.py` are [command](https://docs.djangoproject.com/en/2.2/ref/django-admin/) util provided by django.

`django-admin` is used for administrative task and can be used to build/start a new Django project with default settings/files.&#x20;

`manage.py` on other hand is created in each Django project and also has same ability as `django-admin` but also sets the `DJANGO_SETTINGS_MODULE` environment variable which points to our setting file (depending on the env, we can change the setting).&#x20;

{% code title="manage.py" %}
```python
import os

#example of using dotted.path to our setting.py (myapp/settings/local.py) file 
os.envron.setdefault("DJANGO_SETTINGS_MODULE", "myapp.settings.local")
```
{% endcode %}

we can use `django-admin` to start a project `django-admin startproject admin`&#x20;

```
#following strcture is generated

admin/ #root direc can be named anything
    manage.py #cmd-line utils
    admin/ 
        __init__.py #file to tell python this directory files are package/modules
        settings.py #configs on module-level
        urls.py #mapping of urls 
        wsgi.py #entry point for WSGI server to interact with our applicaiton
```

we can use `manage.py` to generate a skeleton for our apps `python manage.py startapp app_name`

```
#skeleton for apps dir

app_name/ 
    __init__.py
    admin.py    #handling models in admin interface
    apps.py    #defines it is a app (AppNameConfig class)
    migrations/    #dirc containg migraiton for models in future
        __init__.py
    models.py    #define models
    tests.py    
    views.py/    #define views
```

> ## Project can contain multiple apps and an app can be in multiple projects.

### Settings

As name perceived the [settings](https://docs.djangoproject.com/en/2.2/topics/settings/) file contains the configuration of the dajngo installation.

Setting file is just another Python module with module-level variables.

```
DEBUG = False
LANGUAGE_CODE = 'eng-us'
```

&#x20;we can see what settings were changed from default/`global_settings.py` with `manage.py diffsettings` .

we can also import the setting object to our modules

```python
from django.conf import settings

if settings.DEBUG:
    # Do something
```

#### Helpful links

* [Models doc](https://docs.djangoproject.com/en/2.2/topics/db/models/)
* [Making queries](https://docs.djangoproject.com/en/2.2/topics/db/queries/)
* [URLs](https://docs.djangoproject.com/en/2.2/topics/http/urls/)
* [Templates](https://docs.djangoproject.com/en/2.2/topics/templates/)
* [Settings](https://docs.djangoproject.com/en/2.2/topics/settings/)
*
